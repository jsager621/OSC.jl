var documenterSearchIndex = {"docs":
[{"location":"client_server/#Server-and-Client","page":"Client and Server","title":"Server and Client","text":"","category":"section"},{"location":"client_server/#Server","page":"Client and Server","title":"Server","text":"","category":"section"},{"location":"client_server/","page":"Client and Server","title":"Client and Server","text":"You can run an OSCUDPServer that automatically dispatches callbacks via address matching like this:","category":"page"},{"location":"client_server/","page":"Client and Server","title":"Client and Server","text":"using Sockets\nusing OSC\n\nfunction myCallback(srv, args)\n    println(args)\nend\n\nfunction myOtherCallback(srv, args)\n    println(srv)\nend\n\ncallbacks = Dict{String, Function}(\n        \"/testmsg\" => (s, args) -> myCallback(s, args)\n        \"/another/msg\" => (s, args) -> myOtherCallback(s, args)\n    )\n\nsrv = OSCServerUDP(ip\"127.0.0.1\", 8000, callbacks)\n\n# server now automatically handles incoming OSC messages\n# and calls myCallback or myOtherCallback if the messages\n# address pattern fits.\nt = Threads.@spawn listenForever(srv)\n\n# do some other things\n# ....\nsleep(5)\n\n# close the server socket\nclose(srv)","category":"page"},{"location":"client_server/#Client","page":"Client and Server","title":"Client","text":"","category":"section"},{"location":"client_server/","page":"Client and Server","title":"Client and Server","text":"The OSCClientUDP is a simple wrapper around a UDPSocket that ensures sending a packet does not exceed the max_payload size. Additionally, the package defines send functions on top of Sockets.send to directly pass OSCMessage and OSCBundle objects to a UDPSocket.","category":"page"},{"location":"client_server/","page":"Client and Server","title":"Client and Server","text":"using OSC\n\nblob = OSCBlob(UInt32(8), UInt8[0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8])\nbase_types = OSCMessage(\n        \"/testmsg\", \n        \"ifsb\", \n        Int32(5),\n        Float32(6),\n        \"test\",\n        blob)\n\nprintln(base_types)\nprintln(encodeOSC(base_types))\n\n# object will be encoded automatically\nsend(sock, HOST, PORT, base_types)\n\n# equivalent to\nsend(sock, HOST, PORT, encodeOSC(base_types))\n\n# or via the client object that ensures payload size limits\nclient = OSCClientUDP(1024)\nsend(client, HOST, PORT, base_types)","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [OSC]\nPrivate = false\nPages = [\"OSCTypes.jl\"]","category":"page"},{"location":"api/#OSC.OSCBlob","page":"API","title":"OSC.OSCBlob","text":"OSCBlob type to send blob elements via OSC. Consists of the 32 bit size and the corresponding data vector.\n\n\n\n\n\n","category":"type"},{"location":"api/#OSC.OSCBundle","page":"API","title":"OSC.OSCBundle","text":"OSCBundle type consisting of a timetag and a vector of BundleElements.\n\n\n\n\n\n","category":"type"},{"location":"api/#OSC.OSCBundleElement","page":"API","title":"OSC.OSCBundleElement","text":"Parent type for elements in an OSCBundle. Consists of the element size and its content.\n\n\n\n\n\n","category":"type"},{"location":"api/#OSC.OSCMessage","page":"API","title":"OSC.OSCMessage","text":"Basic OSCMessage consisting of an address, format and a list of args. Contents are in parsed form, meaning the initial ',' in the format string or any trailing null bytes in the data are not present here.\n\n\n\n\n\n","category":"type"},{"location":"api/#OSC.OSCParseException","page":"API","title":"OSC.OSCParseException","text":"Exception indicating an error while parsing an OSCMessage or OSCBundle from an input buffer.\n\n\n\n\n\n","category":"type"},{"location":"api/#Encode-and-Parse","page":"API","title":"Encode and Parse","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [OSC]\nPrivate = false\nPages = [\"parse_encode.jl\"]","category":"page"},{"location":"api/#OSC.encodeOSC-Tuple{OSCMessage}","page":"API","title":"OSC.encodeOSC","text":"encodeOSC(msg)\nencodeOSC(bundle)\n\nEncode the given msg or bundle into its network output byte vector.\n\nExamples\n\njulia> println(encodeOSC(OSCMessage(\"/test\", \"T\", true)))\nUInt8[0x2f, 0x74, 0x65, 0x73, 0x74, 0x00, 0x00, 0x00, 0x2c, 0x54, 0x00, 0x00]\n\n\njulia> println(encodeOSC(OSCBundle(UInt64(1234), [OSCBundleElement(OSCMessage(\"/test\", \"T\", true))])))\nUInt8[0x23, 0x62, 0x75, 0x6e, 0x64, 0x6c, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xd2, 0x00, 0x00, 0x00, 0x0c, 0x2f, 0x74, 0x65, 0x73, 0x74, 0x00, 0x00, 0x00, 0x2c, 0x54, 0x00, 0x00]\n\n\n\n\n\n","category":"method"},{"location":"api/#OSC.encodedOSCSize-Tuple{OSCMessage}","page":"API","title":"OSC.encodedOSCSize","text":"encodedOSCSize(msg)\nencodedOSCSize(bundle)\n\nCalculate the encoded size of the given msg or bundle in bytes.\n\n\n\n\n\n","category":"method"},{"location":"api/#OSC.parseOSC-Tuple{Vector{UInt8}}","page":"API","title":"OSC.parseOSC","text":"parseOSC(buffer)\n\nParse buffer into an OSCBundle if it starts with '#bundle'. Otherwise parse buffer into an OSCMessage\n\nExamples\n\njulia> parseOSC(UInt8[0x2f, 0x74, 0x65, 0x73, 0x74, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00, 0x00])\nOSCMessage:\naddress: /test\nformat: \nargs: Any[]\n\njulia> parseOSC(UInt8[0x23, 0x62, 0x75, 0x6e, 0x64, 0x6c, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xd2, 0x00, 0x00, 0x00, 0x0c, 0x2f, 0x74, 0x65, 0x73, 0x74, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00, 0x00]\n       )\nOSCBundle:\ntimetag: 1234\n\nelement:OSCBundleElement:\nsize: 12\ncontent: OSCMessage:\naddress: /test\nformat: \nargs: Any[]\n\n\n\n\n\n","category":"method"},{"location":"api/#Client","page":"API","title":"Client","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [OSC]\nPrivate = false\nPages = [\"client.jl\"]","category":"page"},{"location":"api/#OSC.OSCClientUDP","page":"API","title":"OSC.OSCClientUDP","text":"Client for sending OSC messages via UDP. Creates its own UDP socket. On send, it enforces that the packet does not excceed the max_payload.\n\n\n\n\n\n","category":"type"},{"location":"api/#Server-and-Matching","page":"API","title":"Server and Matching","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [OSC]\nPrivate = false\nPages = [\"server.jl\", \"matching.jl\"]","category":"page"},{"location":"api/#OSC.OSCServerUDP","page":"API","title":"OSC.OSCServerUDP","text":"OSC Server for handling OSC packages coming in via UDP. Dispatches messages to callback functions defined by match_callbacks.\n\n\n\n\n\n","category":"type"},{"location":"api/#OSC.listenForever-Tuple{OSCServerUDP}","page":"API","title":"OSC.listenForever","text":"listenForever(srv)\n\nContinuously try to read data from the srv.socket. When a packet is read it is parsed to an OSCMessage or OSCBundle and the message contents are dispatched via the match_callbacks dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#OSC.matchOSC-Tuple{StringViews.StringView, StringViews.StringView}","page":"API","title":"OSC.matchOSC","text":"matchOSC(address, patter)\n\nCheck whether the address matches the provided pattern as per the OSC path specification.\n\nExamples\n\n\njulia> matchOSC(\"/test\", \"/test\")\ntrue\n\njulia> matchOSC(\"/test\", \"/*\")\ntrue\n\njulia> matchOSC(\"/some/long/addr\", \"//addr\")\ntrue\n\njulia> matchOSC(\"/dont/match/me\", \"/*/match\")\nfalse\n\njulia> matchOSC(\"/do/match/me\", \"/*/match/me\")\ntrue\n\njulia> matchOSC(\"/do/match/me/5\", \"/*/match/me/[0-9]\")\ntrue\n\njulia> matchOSC(\"/wild/card\", \"/{card,wild}/{card,wild}\")\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#Validate","page":"API","title":"Validate","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [OSC]\nPrivate = false\nPages = [\"validate.jl\"]","category":"page"},{"location":"api/#OSC.validateOSC-Tuple{OSCMessage, Vector{UInt8}}","page":"API","title":"OSC.validateOSC","text":"validateOSC(msg, data)\nvalidateOSC(bundle, data)\n\nCheck whether the given msg or bundle matches the OSC output data.\n\n\n\n\n\n","category":"method"},{"location":"parse_encode/#Encoding-and-Parsing","page":"Encode and Parse","title":"Encoding and Parsing","text":"","category":"section"},{"location":"parse_encode/#Encoding","page":"Encode and Parse","title":"Encoding","text":"","category":"section"},{"location":"parse_encode/","page":"Encode and Parse","title":"Encode and Parse","text":"OSCMessages can be created as julia structs.","category":"page"},{"location":"parse_encode/","page":"Encode and Parse","title":"Encode and Parse","text":"using OSC\n\nmsg = OSCMessage(\"/my/address\", \"ifs\", UInt32(15), Float32(3.45), \"string\")","category":"page"},{"location":"parse_encode/","page":"Encode and Parse","title":"Encode and Parse","text":"OSCBundles consist of a timetag and a numer of OSCBundleElements where a OSCBundleElement can either contain an OSCMessage or another OSCBundle.","category":"page"},{"location":"parse_encode/","page":"Encode and Parse","title":"Encode and Parse","text":"using OSC\n\nmsg = OSCMessage(\"/my/address\", \"ifs\", UInt32(15), Float32(3.45), \"string\")\n\nbundle_element = OSCBundleElement(msg)\nbundle = OSCBundle(UInt64(123456), [bundle_element, bundle_element])","category":"page"},{"location":"parse_encode/","page":"Encode and Parse","title":"Encode and Parse","text":"Both OSCBundle and OSCMessage can be encoded to their Vector{UInt8} representation via the encodeOSC function.","category":"page"},{"location":"parse_encode/","page":"Encode and Parse","title":"Encode and Parse","text":"using OSC\n\nmsg = OSCMessage(\"/my/address\", \"ifs\", UInt32(15), Float32(3.45), \"string\")\nbundle_element = OSCBundleElement(msg)\nbundle = OSCBundle(UInt64(123456), [bundle_element, bundle_element])\n\nencodeOSC(msg)\nencodeOSC(bundle)","category":"page"},{"location":"parse_encode/#Parsing","page":"Encode and Parse","title":"Parsing","text":"","category":"section"},{"location":"parse_encode/","page":"Encode and Parse","title":"Encode and Parse","text":"Any incoming message buffer of the correct format can be parsed to an OSCMessage or OSCBundle struct via the parseOSC function.","category":"page"},{"location":"parse_encode/","page":"Encode and Parse","title":"Encode and Parse","text":"using OSC\n\nmsg = OSCMessage(\"/my/address\", \"ifs\", UInt32(15), Float32(3.45), \"string\")\nbundle_element = OSCBundleElement(msg)\nbundle = OSCBundle(UInt64(123456), [bundle_element, bundle_element])\n\ne_msg = encodeOSC(msg)\ne_bundle = encodeOSC(bundle)\n\nparseOSC(e_msg)\nparseOSC(e_bundle)","category":"page"},{"location":"#OSC.jl","page":"Home","title":"OSC.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the OSC.jl documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"OSC.jl is a pure Julia implementation of the Open Sound Control format. The aim of this library is to provide full OSC 1.1 spec support and convenient APIs for its use.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"message generation\nmessage parsing\nbundle generation\nbundle parsing\naddress matching\nUDP server with address-based dispatching\nUDP client\nall OSC 1.0 types except [ and ] which is in TODOs\nOSC 1.1 // path operator","category":"page"},{"location":"#Development-State","page":"Home","title":"Development State","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The project is in early development and almost certainly still contains bugs. As such, contributions and feature suggestions are greatly encouraged.","category":"page"}]
}
